<?php
/**
 * Copyright (c) 2016 Ben ZÃ¶rb
 * Licensed under the MIT license.
 * http://bezoerb.mit-license.org/
 */

namespace Zoerb\Bundle\FilerevBundle\Asset\VersionStrategy;

use Symfony\Component\Asset\VersionStrategy\VersionStrategyInterface;
use Symfony\Component\Config\ConfigCache;
use Symfony\Component\Config\FileLocator;
use Symfony\Component\Translation\Loader\JsonFileLoader;
use Symfony\Component\Translation\MessageCatalogue;

/**
 * Returns the Version based on json configuration
 *
 * @package Zoerb\Bundle\FilerevBundle\Asset\VersionStrategy
 */
class JsonVersionStrategy implements VersionStrategyInterface
{

    /** @var MessageCatalogue */
    protected $summary;

    /** @var string */
    protected $cacheDir;

    /** @var string */
    protected $summaryFile;

    /** @var string */
    protected $rootDir;

    /** @var int */
    protected $hashLength;

    /** @var string */
    protected $separator;

    /** @var bool */
    protected $debug;


    /**
     * @param string $rootDir
     * @param string $summaryFile
     * @param int $hashLength
     * @param string $cacheDir
     * @param bool $debug
     */
    public function __construct($rootDir, $summaryFile, $hashLength, $separator, $cacheDir, $debug)
    {
        $this->rootDir = $rootDir;
        $this->summaryFile = $summaryFile;
        $this->hashLength = $hashLength;
        $this->separator = $separator;
        $this->cacheDir = $cacheDir;
        $this->debug = $debug;
    }

    /**
     * Get filerev summary
     *
     * @return MessageCatalogue
     * @throws \Exception
     */
    protected function getSummary()
    {
        if (!$this->summary instanceof MessageCatalogue) {
            throw new \Exception('Summary is not injected into '.get_class($this));
        }

        return $this->summary;
    }

    /**
     * Get reved filename from summary
     *
     * @param $file
     *
     * @return string
     */
    protected function getRevedFilename($file)
    {
        $this->initializeCacheCatalogue();
        return $this->summary->get($file);
    }


    /**
     * Initialize filerev catalogue from filerev.json
     *
     * @param string $summaryFile Grunt filerev summary file
     */
    protected function initializeCatalogue($summaryFile)
    {
        // try to fetch config file generated by filerev
        // use empty cataloge if file does not exist
        $locator = new FileLocator(array(
            dirname($summaryFile),
            __DIR__.'/../../Resources/config',
        ));
        try {
            $resources = $locator->locate(basename($summaryFile), null, false);

            if (is_array($resources) && count($resources)) {
                $resource = array_shift($resources);
                $loader = new JsonFileLoader();
                $this->summary = $loader->load($resource, null);
                return;
            }

        } catch (\InvalidArgumentException $e) {
            // no summary set
        }

        $this->summary = new MessageCatalogue(null);
    }


    /**
     * Initialize filerev catalogue from cache
     * or generate cache if not already available
     */
    protected function initializeCacheCatalogue()
    {
        if (isset($this->summary)) {
            return;
        }

        $cache = new ConfigCache($this->getCatalogueCachePath($this->cacheDir), $this->debug);
        if (!$cache->isFresh()) {
            $this->initializeCatalogue($this->summaryFile);

            $content = sprintf(<<<EOF
<?php

use Symfony\Component\Translation\MessageCatalogue;

\$catalogue = new MessageCatalogue(null, %s);

return \$catalogue;

EOF
                ,
                var_export($this->summary->all(), true)
            );

            $cache->write($content, $this->summary->getResources());

            return;
        }

        $this->summary = include $cache->getPath();
    }

    /**
     * Cache path
     *
     * @param string $cacheDir Kernel cache dir
     *
     * @return string
     */
    protected function getCatalogueCachePath($cacheDir)
    {
        return $cacheDir.'/filerev.summary.php';
    }

    /**
     * Returns the asset version for an asset.
     *
     * @param string $path A path
     *
     * @return string The version string
     */
    public function getVersion($path)
    {
        $versionized = $this->applyVersion($path);
        $regex = preg_replace('/\.([^\.]+$)/', '\.[\d\w]{'.$this->hashLength.'}\.$1', $versionized);

        if (preg_match('#'.$regex.'#', $versionized, $match)) {
            return $match[1];
        }

        return '';
    }

    /**
     * Applies version to the supplied path.
     *
     * @param string $path A path
     *
     * @return string The versionized path
     */
    public function applyVersion($path)
    {
        $reved = $this->getRevedFilename($path);

        $absPath = implode(DIRECTORY_SEPARATOR, [$this->rootDir,$path]);
        $absReved = implode(DIRECTORY_SEPARATOR, [$this->rootDir,$reved]);

        // $reved or unversioned
        if (file_exists($absReved)) {
            return $reved;

            // look in filesystem
        } else {
            $pattern = preg_replace('/\.([^\.]+$)/', $this->separator.'*.$1', $absPath);
            $regex = preg_replace('/\.([^\.]+$)/', '\\'.$this->separator.'[\d\w]{'.$this->hashLength.'}\.$1', $absPath);
            $base = str_replace($path, '', $absPath);
            foreach (glob($pattern) as $filepath) {
                if (preg_match('#'.$regex.'#', $filepath, $match)) {
                    $result = str_replace($base, '', $filepath);
                    $this->summary->set($path, $result);

                    return $result;
                }
            };

        }

        return $path;
    }
}
